# GVM: Go Stack-Based Virtual Machine

GVM (Go Virtual Machine) is a lightweight, stack-based virtual machine implemented in Go, designed to provide a flexible and extensible execution environment for a custom low-level programming language. This project includes a complete toolchain with an assembler, virtual machine runtime, and heap-based memory management system.

## Table of Contents

- [Overview](#overview)
- [Features](#features)
- [Architecture](#architecture)
- [Instruction Set](#instruction-set)
- [Type System](#type-system)
- [Memory Management](#memory-management)
- [System Calls](#system-calls)
- [Example Programs](#example-programs)
- [Building and Running](#building-and-running)
- [Project Structure](#project-structure)
- [Contributing](#contributing)

## Overview

GVM implements a complete execution environment, including:

- A custom assembler for a stack-based language
- A virtual machine for executing the generated bytecode
- A heap implementation for memory management
- Support for user-defined structures and functions

The VM uses a stack-based architecture where operations primarily work with values on the stack rather than in registers. This design simplifies the instruction set and makes the VM implementation more straightforward while maintaining sufficient power for complex programs.

## Features

### Assembler
- **Lexical Analysis**: Tokenizes source code into meaningful tokens
- **Parsing**: Converts tokens into an abstract syntax tree (AST)
- **Code Generation**: Translates the AST into bytecode for the VM
- **Struct Definitions**: Support for user-defined composite types
- **Functions**: Support for procedure definitions with parameters and return values

### Virtual Machine
- **Stack-based Execution Model**: Operations work directly with the stack
- **Call Stack**: Maintains function call frames for procedure invocation
- **Bytecode Interpreter**: Executes compiled bytecode operations
- **Type Safety**: Runtime type checking for operations
- **Debug Mode**: Detailed execution tracing and state visualization

### Memory Management
- **Heap Allocation**: Dynamic memory management
- **Garbage Collection**: Manual memory management with explicit free operations
- **Memory Safety**: Bounds checking and type verification on memory operations

## Architecture

The system is composed of several main components:

1. **Lexer**: Reads source code and produces tokens
2. **Parser**: Takes tokens and builds an abstract syntax tree
3. **Code Generator**: Converts the AST into bytecode
4. **Virtual Machine**: Executes bytecode operations
5. **Heap Manager**: Handles memory allocation and deallocation

The compilation and execution pipeline works as follows:

```
Source Code → Lexer → Tokens → Parser → AST → Code Generator → Bytecode → VM Execution
```

## Instruction Set

GVM supports a comprehensive set of instructions, organized into the following categories:

### Stack Manipulation
- `push`: Push values onto the stack
- `pop`: Remove the top value from the stack
- `dup`: Duplicate the top value on the stack

### Arithmetic Operations
- Integer operations: `iadd`, `isub`, `imul`, `idiv`
- Float operations: `fadd`, `fsub`, `fmul`, `fdiv`

### Memory Operations
- `store`: Store a value in a local variable
- `load`: Load a value from a local variable
- `alloc`: Allocate memory on the heap
- `free`: Free allocated memory
- `loadh`: Load a value from the heap
- `storeh`: Store a value to the heap

### Control Flow
- `jmp`: Unconditional jump
- `ije`, `ijne`: Integer conditional jumps (jump if equal/not equal)
- `fje`, `fjne`: Float conditional jumps (jump if equal/not equal)
- `call`: Function call
- `ret`: Return from function with value
- `retv`: Return from function without value (void)

### Comparison Operations
- `eq`, `ne`: Equal, not equal
- `lt`, `le`: Less than, less than or equal
- `gt`, `ge`: Greater than, greater than or equal

### Array Operations
- `newarr`: Create a new array
- `ldelem`: Load an element from an array
- `stelem`: Store an element to an array

### Struct Operations
- `newstruct`: Create a new struct instance
- `fldget`: Get a field value from a struct
- `stfield`: Set a field value in a struct

### String Operations
- `stralloc`: Allocate a string

## Type System

GVM supports various value types:

- `int32`: 32-bit signed integers
- `float32`: 32-bit floating point numbers
- `pointer`: Memory addresses
- `string`: Text strings
- `array`: Sequences of values
- `struct`: User-defined composite types
- `void`: Used for functions with no return value
- `byte`: 8-bit unsigned integers

Each value carries type information, allowing the VM to perform type checking at runtime. Type mismatch errors are reported with descriptive error messages.

## Memory Management

The VM uses a simple memory management system:

1. **Stack**: Automatically managed per function call frame
2. **Locals**: Function-local variables mapped by numeric indices
3. **Heap**: Explicit allocation and freeing of memory blocks

The heap implementation uses the system's memory mapping facilities to allocate pages of memory and tracks allocated blocks to prevent memory leaks and invalid accesses.

## System Calls

GVM includes a system call mechanism for interacting with the host environment. The following syscalls are available:

- `STR_LEN (0)`: Get the length of a string
  ```
  ; Push the string pointer
  ; Call syscall
  syscall str_len
  ; Result (int32) is pushed onto the stack
  ```

- `STR_CAT (1)`: Concatenate two strings
  ```
  ; Push two string pointers
  ; Call syscall
  syscall str_cat
  ; Result (pointer to new string) is pushed onto the stack
  ```

- `STR_EQUALS (2)`: Compare two strings for equality
  ```
  ; Push two string pointers
  ; Call syscall
  syscall str_equals
  ; Result (1 for equal, 0 for not equal) is pushed onto the stack
  ```

- `WRITE_BYTE (3)`: Write a byte to standard output
  ```
  ; Push a byte or int32 value
  push byte 65  ; ASCII 'A'
  syscall write_byte
  ```

- `READ_BYTE (4)`: Read a byte from standard input
  ```
  ; Call syscall
  syscall read_byte
  ; Result (byte) is pushed onto the stack
  ```

## Example Programs

### Hello World
```
.text
    func main() -> void {
        ; ASCII values for "Hello, World!"
        push byte 72  ; H
        syscall write_byte
        push byte 101 ; e
        syscall write_byte
        push byte 108 ; l
        syscall write_byte
        push byte 108 ; l
        syscall write_byte
        push byte 111 ; o
        syscall write_byte
        push byte 44  ; ,
        syscall write_byte
        push byte 32  ; space
        syscall write_byte
        push byte 87  ; W
        syscall write_byte
        push byte 111 ; o
        syscall write_byte
        push byte 114 ; r
        syscall write_byte
        push byte 108 ; l
        syscall write_byte
        push byte 100 ; d
        syscall write_byte
        push byte 33  ; !
        syscall write_byte
        push byte 10  ; newline
        syscall write_byte
    }
```

### Basic Arithmetic
```
.text
    func main() -> void {
        push int32 10
        push int32 20
        iadd          ; 10 + 20 = 30
        
        push int32 5
        imul          ; 30 * 5 = 150
        
        push int32 2
        idiv          ; 150 / 2 = 75
        
        ; Result 75 is on top of the stack
        ret
    }
```

### Creating and Using Structs
```
.structs
    struct Point {
        x: int32
        y: int32
    }

.text
    func newPoint(x: int32, y: int32) -> Point {
        store 0  ; Store x
        store 1  ; Store y
        newstruct Point
        dup
        load 0
        stfield "x"
        dup
        load 1
        stfield "y"
        ret
    }

    func main() -> void {
        push int32 5
        push int32 10
        call newPoint
        dup
        fldget "x"  ; Get x value (5)
        dup
        fldget "y"  ; Get y value (10)
        ret
    }
```

### Working with Arrays
```
.text
    func main() -> void {
        push int32 5    ; Array length
        newarr int32    ; Create int array
        dup
        push int32 0    ; Index
        push int32 42   ; Value
        stelem          ; arr[0] = 42
        
        dup
        push int32 0    ; Index
        ldelem          ; Get arr[0] (42)
        ret
    }
```

## Building and Running

### Prerequisites
- Go 1.22 or later

### Build
```bash
go mod tidy
go build
```

### Run a Program
```bash
./gvm program.asm
```

## Project Structure

- `assembler/`: Lexer, parser, and code generation
  - `lexer.go`: Tokenizer for source code
  - `parser.go`: Parser for tokens to AST
  - `codeGenerator.go`: Bytecode generation
  - `token.go`: Token definitions
  - `assembler.go`: Main assembler interface
- `vm/`: Virtual machine implementation
  - `vm.go`: Core VM implementation
  - `opcodes.go`: Instruction definitions
  - `syscalls.go`: System call implementations
- `heap/`: Memory management
  - `heap.go`: Heap allocation and management
- `common/`: Shared types and utilities
  - `types.go`: Value types and operations
