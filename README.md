# Stack VM

Stack VM is a custom stack-based virtual machine implemented in Go, designed to provide a flexible and extensible execution environment for a low-level programming language.

## Table of Contents
- [Overview](#overview)
- [Features](#features)
- [Architecture](#architecture)
- [Instruction Set](#instruction-set)
- [Type System](#type-system)
- [Memory Management](#memory-management)
- [Example Programs](#example-programs)
- [Building and Running](#building-and-running)
- [Testing](#testing)
- [Project Structure](#project-structure)
- [Contributing](#contributing)

## Overview

Stack VM implements a complete execution environment, including a custom assembler for a stack-based language, a virtual machine for executing the generated bytecode, and a heap implementation for memory management. This project is designed for educational purposes and as a foundation for language design experiments.

The VM uses a stack-based architecture where operations primarily work with values on the stack rather than in registers. This design simplifies the instruction set and makes the VM implementation more straightforward.

## Features

### Assembler
- **Lexical Analysis**: Tokenizes source code into meaningful tokens
- **Parsing**: Converts tokens into an abstract syntax tree (AST)
- **Code Generation**: Translates the AST into bytecode for the VM
- **Struct Definitions**: Support for user-defined composite types
- **Functions**: Support for procedure definitions with parameters and return values

### Virtual Machine
- **Stack-based Execution Model**: Operations work directly with the stack
- **Call Stack**: Maintains function call frames for procedure invocation
- **Bytecode Interpreter**: Executes compiled bytecode operations
- **Type Safety**: Runtime type checking for operations
- **Debug Mode**: Detailed execution tracing and state visualization

### Memory Management
- **Heap Allocation**: Dynamic memory management
- **Garbage Collection**: Manual memory management with explicit free operations
- **Memory Safety**: Bounds checking and type verification on memory operations

## Architecture

The system is composed of several main components:

1. **Lexer**: Reads source code and produces tokens
2. **Parser**: Takes tokens and builds an abstract syntax tree
3. **Code Generator**: Converts the AST into bytecode
4. **Virtual Machine**: Executes bytecode operations
5. **Heap Manager**: Handles memory allocation and deallocation

The compilation and execution pipeline works as follows:

```
Source Code → Lexer → Tokens → Parser → AST → Code Generator → Bytecode → VM Execution
```

## Instruction Set

The VM supports a comprehensive set of instructions, organized into the following categories:

### Stack Manipulation
- `push`: Push values onto the stack
- `pop`: Remove the top value from the stack
- `dup`: Duplicate the top value on the stack

### Arithmetic Operations
- Integer operations: `iadd`, `isub`, `imul`, `idiv`
- Float operations: `fadd`, `fsub`, `fmul`, `fdiv`

### Memory Operations
- `store`: Store a value in a local variable
- `load`: Load a value from a local variable
- `alloc`: Allocate memory on the heap
- `free`: Free allocated memory
- `loadh`: Load a value from the heap
- `storeh`: Store a value to the heap

### Control Flow
- `jmp`: Unconditional jump
- `ije`, `ijne`: Integer conditional jumps
- `fje`, `fjne`: Float conditional jumps
- `call`: Function call
- `ret`: Return from function with value
- `retv`: Return from function without value (void)

### Comparison Operations
- `eq`, `ne`: Equal, not equal
- `lt`, `le`: Less than, less than or equal
- `gt`, `ge`: Greater than, greater than or equal

### Array Operations
- `newarr`: Create a new array
- `ldelem`: Load an element from an array
- `stelem`: Store an element to an array

### Struct Operations
- `newstruct`: Create a new struct instance
- `fldget`: Get a field value from a struct
- `stfield`: Set a field value in a struct

### String Operations
- `stralloc`: Allocate a string
- Various syscalls for string manipulation

## Type System

Stack VM supports various value types:

- `int32`: 32-bit signed integers
- `float32`: 32-bit floating point numbers
- `pointer`: Memory addresses
- `string`: Text strings
- `array`: Sequences of values
- `struct`: User-defined composite types
- `void`: Used for functions with no return value

Each value carries type information, allowing the VM to perform type checking at runtime. Type mismatch errors are reported with descriptive error messages.

## Memory Management

The VM uses a simple memory management system:

1. **Stack**: Automatically managed per function call frame
2. **Locals**: Function-local variables mapped by numeric indices
3. **Heap**: Explicit allocation and freeing of memory blocks

The heap implementation uses the system's memory mapping facilities to allocate pages of memory and tracks allocated blocks to prevent memory leaks and invalid accesses.

## Example Programs

### Basic Arithmetic
```
.text
func main() -> void {
    push int32 10
    push int32 20
    iadd
    ret
}
```

### Creating and Using Structs
```
.structs
struct Point {
    x: int32
    y: int32
}

.text
func newPoint(x: int32, y: int32) -> Point {
    store 0  ; Store x
    store 1  ; Store y
    newstruct Point
    dup
    load 0
    stfield "x"
    dup
    load 1
    stfield "y"
    ret
}

func main() -> void {
    push int32 5
    push int32 10
    call newPoint
    dup
    fldget "x"
    dup
    fldget "y"
    ret
}
```

### Working with Arrays
```
.text
func main() -> void {
    push int32 5    ; Array length
    newarr int32    ; Create int array
    dup
    push int32 0    ; Index
    push int32 42   ; Value
    stelem          ; arr[0] = 42
    ret
}
```

## Building and Running

### Prerequisites
- Go 1.22 or later

### Build
```bash
go mod tidy
go build
```

### Run a Program
```bash
./stack_vm myprogram.svm
```

## Testing

The project includes comprehensive tests for all major components:

```bash
go test ./...
```

Individual component tests can be run with:

```bash
go test ./assembler
go test ./vm
go test ./heap
```

## Project Structure

- `assembler/`: Lexer, parser, and code generation
  - `lexer.go`: Tokenizer for source code
  - `parser.go`: Parser for tokens to AST
  - `codeGenerator.go`: Bytecode generation
  - `token.go`: Token definitions
  - `assembler.go`: Main assembler interface
- `vm/`: Virtual machine implementation
  - `vm.go`: Core VM implementation
  - `opcodes.go`: Instruction definitions
  - `syscalls.go`: System call implementations
- `heap/`: Memory management
  - `heap.go`: Heap allocation and management
- `common/`: Shared types and utilities
  - `types.go`: Value types and operations
